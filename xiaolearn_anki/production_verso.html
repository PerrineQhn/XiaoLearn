<div class="card-container prod-card back" id="cardContainer">
  <div class="hsk-badge">{{HSK_Level}}</div>
  <div class="type-indicator prod-type">ğŸŸ¢ PRODUCTION</div>
  
  <div class="comparison-title">
    Trace par-dessus le guide pour comparer
  </div>
  
  <!-- Conteneur pour les canvas avec guides -->
  <div class="canvas-grid-container" id="canvasGridContainer"></div>
  
  <!-- ContrÃ´les au verso aussi ! -->
  <div class="canvas-controls">
    <button onclick="clearAllCanvas()" class="btn-clear">
      ğŸ—‘ï¸ Effacer
    </button>
    <button onclick="undoLastStroke()" class="btn-undo">
      â†¶ Annuler
    </button>
  </div>
  
  <div class="correct-answer-section">
    <div class="correct-label">âœ… RÃ©ponse correcte</div>
    <div class="chinese-answer">{{Simplified}}</div>
    <div class="pinyin-answer">{{Pinyin}}</div>
  </div>
  
  <div class="meaning-reminder">
    ğŸ“– {{Meaning}}
  </div>
  
  <div class="examples-section">
    <div class="examples-title">ğŸ“š Exemples</div>
    <div class="examples-content">
      {{Examples}}
    </div>
  </div>
  
  <div class="card-footer">
    <div class="tags">{{Tags}}</div>
    <div class="progress-bar">
      <div class="progress-fill"></div>
    </div>
    <div class="motivation-text">ğŸ’ª Pratique le tracÃ© !</div>
  </div>
</div>

<script>
(function() {
  const simplified = '{{Simplified}}';
  const chars = simplified.split('');
  const charCount = chars.length;
  const tags = '{{Tags}}'.toLowerCase();
  
  // DÃ©tecter le type
  const isGrammar = tags.includes('particule') || 
                    tags.includes('grammaire') || 
                    tags.includes('conjonction') ||
                    tags.includes('mesure');
  
  const card = document.getElementById('cardContainer');
  if (isGrammar) {
    card.classList.add('grammar-card');
  } else {
    card.classList.add('vocab-card');
  }
  
  // Conteneur principal
  const container = document.getElementById('canvasGridContainer');
  
  // DÃ©terminer la taille selon le nombre de caractÃ¨res
  let canvasSize, gridClass, fontSize;
  if (charCount === 1) {
    canvasSize = 300;
    gridClass = 'canvas-grid-1';
    fontSize = 200;
  } else if (charCount === 2) {
    canvasSize = 150;
    gridClass = 'canvas-grid-2';
    fontSize = 100;
  } else if (charCount === 3) {
    canvasSize = 100;
    gridClass = 'canvas-grid-3';
    fontSize = 70;
  } else {
    canvasSize = 150;
    gridClass = 'canvas-grid-4';
    fontSize = 100;
  }
  
  // Ajouter la classe
  container.classList.add(gridClass);
  
  // âœ… NOUVEAU : Tableau pour stocker les managers de dessin
  window.canvasManagers = [];
  
  // CrÃ©er un canvas avec guide ET systÃ¨me de dessin pour chaque caractÃ¨re
  chars.forEach((char, index) => {
    const wrapper = document.createElement('div');
    wrapper.className = 'canvas-item';
    
    // Guide du caractÃ¨re
    const guide = document.createElement('div');
    guide.className = 'char-guide';
    guide.textContent = char;
    guide.style.fontSize = `${fontSize}px`;
    
    // Canvas avec DESSIN ACTIVÃ‰
    const canvas = document.createElement('canvas');
    canvas.id = `canvas-back-${index}`;
    canvas.width = canvasSize * 2;
    canvas.height = canvasSize * 2;
    canvas.style.width = `${canvasSize}px`;
    canvas.style.height = `${canvasSize}px`;
    
    // Grille
    const grid = document.createElement('div');
    grid.className = 'canvas-grid';
    
    wrapper.appendChild(guide);
    wrapper.appendChild(canvas);
    wrapper.appendChild(grid);
    container.appendChild(wrapper);
    
    // âœ… NOUVEAU : Initialiser le systÃ¨me de dessin pour ce canvas
    const manager = initCanvasManager(canvas);
    window.canvasManagers.push(manager);
  });
  
  // âœ… NOUVEAU : Fonction pour initialiser le dessin sur un canvas
  function initCanvasManager(canvas) {
    const ctx = canvas.getContext('2d');
    let isDrawing = false;
    let strokes = [];
    let currentStroke = [];
    
    // Configuration du pinceau
    ctx.strokeStyle = '#2c3e50';
    ctx.lineWidth = 20;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    function getPos(e) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      
      let clientX, clientY;
      if (e.touches && e.touches.length > 0) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }
      
      return {
        x: (clientX - rect.left) * scaleX,
        y: (clientY - rect.top) * scaleY
      };
    }
    
    function startDrawing(e) {
      e.preventDefault();
      e.stopPropagation();
      isDrawing = true;
      currentStroke = [];
      const pos = getPos(e);
      currentStroke.push(pos);
      ctx.beginPath();
      ctx.moveTo(pos.x, pos.y);
    }
    
    function draw(e) {
      if (!isDrawing) return;
      e.preventDefault();
      e.stopPropagation();
      const pos = getPos(e);
      currentStroke.push(pos);
      ctx.lineTo(pos.x, pos.y);
      ctx.stroke();
    }
    
    function stopDrawing(e) {
      if (!isDrawing) return;
      e.preventDefault();
      e.stopPropagation();
      isDrawing = false;
      if (currentStroke.length > 0) {
        strokes.push([...currentStroke]);
      }
    }
    
    // Ã‰vÃ©nements souris
    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseout', stopDrawing);
    canvas.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
    });
    
    // Ã‰vÃ©nements tactiles
    canvas.addEventListener('touchstart', startDrawing, {passive: false});
    canvas.addEventListener('touchmove', draw, {passive: false});
    canvas.addEventListener('touchend', stopDrawing, {passive: false});
    canvas.addEventListener('touchcancel', stopDrawing, {passive: false});
    
    return {
      canvas,
      ctx,
      clear: function() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        strokes = [];
      },
      undo: function() {
        if (strokes.length === 0) return;
        strokes.pop();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        strokes.forEach(stroke => {
          if (stroke.length === 0) return;
          ctx.beginPath();
          ctx.moveTo(stroke[0].x, stroke[0].y);
          stroke.forEach(point => ctx.lineTo(point.x, point.y));
          ctx.stroke();
        });
      }
    };
  }
  
  // âœ… NOUVEAU : Fonctions globales pour les boutons
  window.clearAllCanvas = function() {
    window.canvasManagers.forEach(m => m.clear());
  };
  
  window.undoLastStroke = function() {
    // Annuler sur tous les canvas (ou juste le dernier si tu prÃ©fÃ¨res)
    window.canvasManagers.forEach(m => m.undo());
  };
})();
</script>
